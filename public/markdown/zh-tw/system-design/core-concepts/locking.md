# Locking

在系統中，當存在需「互斥存取」的共享資源時（例如共享計數器「如庫存數量」或物理設備控制「如吊橋升起控制」），鎖定機制用於確保同一時間僅一個客戶端能存取該資源。

鎖定存在於計算系統的各層級：

- 作業系統核心：控制硬體資源存取。
- 應用程式層：管理多執行緒資源競爭。
- 資料庫：確保交易原子性（如行級鎖、表級鎖）。
- 分散式系統：跨節點協調（如分散式鎖）。

鎖定對系統正確性至關重要，但過度使用可能嚴重影響效能。在系統設計面試中，當討論競爭條件（Race Condition）時，鎖定機制往往是核心議題。

- Granularity of the lock (鎖定粒度)

  - 原則：鎖定範圍應盡可能細緻，避免無謂阻擋其他操作。
  - 範例：
    - 更新用戶資料時，僅鎖定該用戶的資料列（Row-Level Lock），而非鎖定整個用戶表（Table-Level Lock）。
    - 分散式系統中，鎖定特定資源（如「用戶A的訂單」）而非全域鎖定。

- Duration of the lock (鎖定持續時間)

  - 原則：鎖定應在「關鍵區段（Critical Section）」完成後立即釋放，最小化阻塞時間。
  - 範例：
    - 資料庫交易中，寫入完成後立即提交（Commit）並釋放鎖，而非保持鎖定至整個 HTTP 請求結束。

- Whether we can bypass the lock (能否繞過鎖定)

  - Optimistic Concurrency Control(樂觀併發控制)：

    - 假設競爭極少發生，先執行操作，再檢查是否衝突（如透過**比較並交換（Compare and Swap, CAS）**機制）。
    - 適用場景：讀多寫少、操作可重試（如更新商品描述）。
    - 優點：無鎖阻塞，高吞吐量。
    - 缺點：衝突時需重試，增加複雜度。

  - Pessimistic Locking(悲觀鎖定)：
    - 預先取得鎖再執行操作（如 SELECT FOR UPDATE）。
    - 適用場景：高競爭寫入（如庫存扣減、金融轉帳）。
    - 優點：保證操作原子性，避免重試。
    - 缺點：鎖定時間過長可能導致效能瓶頸。

- Lock衍伸問題
  - Deadlock
    - 成因：多個鎖定循環等待（如 A 等 B，B 等 A）。
    - 解決：設定鎖定超時、按固定順序取得鎖、死鎖檢測機制。
  - Starvation
    - 成因：高優先級操作持續搶占鎖定，低優先級操作永遠無法取得。
    - 解決：公平佇列（Fair Queue）或權重分配。
  - 分散式鎖的Clock Drift：
    - 成因：節點間時鐘不同步導致鎖過期時間誤判。
    - 解決：使用租約（Lease）機制與Logical Clock（如 Google Chubby）。
    - 電商搶購活動： Redis Redlock + 租約 (高併發、容錯需求高，允許短暫不一致)
    - 分散式資料庫協調（如 etcd）： Raft 協議 + 邏輯時鐘 (需強一致性與事件順序保證)
    - 微服務任務排程： ZooKeeper 臨時節點 (需精確控制任務分配與節點存活狀態)
