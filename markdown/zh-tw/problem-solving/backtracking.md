# Backtracking

Backtracking的本質就是窮舉法。列出所有可能然後選出我們想要的答案。如果想要提高他的效率，我們可以加上剪枝的操作，但也改變不了窮舉的本質。擅長處理：
- 排列組合問題（如全排列、組合總和）
- 子集生成（如所有可能子集） 
- 路徑搜索（如迷宮問題、N皇后）
- 分割問題（如回文分割）

## 實作要點
// 通用模板框架
function backtrack(路徑, 選擇列表) {
    if (終止條件) {
        記錄解;
        return;
    }
    
    for (選擇 of 選擇列表) {
        做選擇;
        backtrack(新路徑, 新選擇列表);
        撤銷選擇; // 關鍵步驟！
    }
}

  - 狀態管理
    - 使用可變動的資料結構（如 list）儲存當前路徑
    - 進入遞迴前修改狀態，退出後必須恢復原狀
  - 剪枝優化
    - 排序後處理（適用組合類問題，避免重複解）
    - 提前終止無效分支（如總和已超過目標值時）
  - 終止條件精度
    - 明確定義遞迴終止的邊界條件
    - 範例：N皇后問題中當 row == n 時記錄解
  - 選擇列表生成
    - 動態過濾已用元素（排列問題常用 visited 數組）
    - 處理可重複/不可重複使用的差異邏輯
