# Distributed Cache

在大多數的系統設計面試中，你都會被要求擴展你的系統並降低系統延遲。一種常見的方法是使用分散式快取。快取只是一個伺服器或伺服器集群，用於在記憶體中儲存資料。它們非常適合儲存計算成本高昂或從資料庫中檢索成本高昂的資料。

## 使用場景：

- Save Aggregated Metrics
  - 考慮一個分析平台，它彙總來自眾多來源的資料，以顯示指標儀表板。這些指標的資料計算成本高昂，因此平台會非同步計算指標（例如，透過背景作業每小時計算一次），並將結果儲存在分散式快取中。當使用者請求儀表板時，平台可以從快取中檢索資料，而不是重新計算，從而降低延遲。
- Reduce Number of DB Queries:
  - 在網路應用程式中，使用者會話通常儲存在分散式快取中，以減少資料庫的負載。這對於需要支援大量並行使用者的系統尤其重要。當使用者登入時，系統可以將他們的會話資料儲存在快取中，讓系統在使用者發出請求時快速檢索資料。
- Speed Up Expensive Queries
  - 一些複雜的查詢在傳統的、基於磁碟的資料庫上需要很長時間才能執行。例如，如果你有一個像 Twitter 這樣的社交媒體平台，你可能想向使用者顯示他們關注的人的貼文列表。這是一個複雜的查詢，需要連接多個表格並按多個欄位進行篩選。在 Postgres 上執行此查詢可能需要很長時間。相反，你可以執行一次查詢，將結果儲存在分散式快取中，然後在使用者請求時從快取中檢索結果。

## 常見面試知識點：

- Eviction Policy
  - 當快取空間不足時，決定哪些資料應被移除的規則機制。常見策略：
    - LRU（最近最少使用）：優先移除最久未被存取的資料。  
      _範例：_ 類似用戶的瀏覽記錄，系統會自動刪除長期未查看的頁面。
    - FIFO（先進先出）：按存入時間順序移除最早的資料。  
      _範例：_ 如電商限時特賣商品列表，舊活動自動下架。
    - LFU（最不常使用）：移除使用頻率最低的資料。  
      _範例：_ 快取的熱門新聞中，若某篇點擊次數驟降，系統會優先淘汰它。
- Cache Invalidation Strategy

  - 確保快取資料與原始資料來源（如資料庫）保持一致性。  
    _核心邏輯：_ 當底層資料更新時，主動淘汰或更新快取。  
    _範例：_  
    若設計演唱會售票系統（如 Ticketmaster），當某場次 「場地變更」 時，需立即刪除對應的活動快取，否則用戶可能看到過期資訊。

- Cache Write Strategy
  定義如何將資料寫入快取與持久層，平衡效能與一致性。

  - Write-Through（穿透寫入）：同步寫入快取和資料庫。  
    _優點：_ 資料一致性高。  
    _缺點：_ 寫入延遲較高。  
    _適用場景：_ 銀行交易系統，需即時確保帳戶餘額正確。
  - Write-Around（繞過寫入）：直接寫入資料庫，不更新快取。  
    _優點：_ 避免快取被冷門資料占滿。  
    _缺點：_ 後續讀取需重新加載資料。  
    _適用場景：_ 大量寫入的日誌系統，不需頻繁讀取舊紀錄。
  - Write-Back（回寫式）：先寫入快取，異步延遲寫入資料庫。  
    _優點：_ 寫入效能最佳。  
    _缺點：_ 系統崩潰時可能丟失未同步的資料。  
    _適用場景：_ 社群媒體的「按讚」功能，容忍短暫資料不一致。

::TIPS
在設計系統時，請明確說明您將哪些數據存儲在緩存中，包括所使用的數據結構類型。需要特別注意的是，現代緩存系統支持多種數據結構，而不再僅限於單純的鍵值存儲。舉例來說，若您計劃在緩存中存儲一系列活動事件，採用「有序集合」這一數據結構會是更優選擇，因為它能便捷地實現「獲取熱門活動」這一常見操作。許多設計者僅籠統地表示「我將活動存入緩存」便止步不前，這不僅錯失了展示技術深度的機會，也可能引發面試官或團隊成員的後續追問。

假設開發一個活動推薦系統，您需要緩存即將舉辦的100場音樂節信息。若使用普通鍵值存儲，只能以活動ID為鍵、活動詳情為值進行存儲。但若採用Redis的有序集合（Sorted Set）：

```python
# 將音樂節按票務銷量排序存入緩存
redis.zadd("music_festivals", {
    "Lollapalooza_2023": 150000,
    "Coachella_2023": 250000,
    "Ultra_Miami_2023": 95000
})
# 獲取消費量前10的熱門音樂節
top_events = redis.zrevrange("music_festivals", 0, 9, withscores=True)
```

這種設計不僅實現了數據存儲，還直接支持熱門活動的實時排序檢索，避免了從數據庫反覆查詢的性能損耗，較之簡單鍵值存儲更顯專業性。
::

## 進階設計模式：

- 快取擊穿防護：採用 Bloom filter + 互斥鎖定機制

  - 當某個「不存在於快取中也不存在於資料庫」的數據（如無效商品ID），突然遭遇高併發查詢時，大量請求會穿透快取直接壓垮資料庫，此現象稱為「快取擊穿」。

    - Bloom filter 前置檢查

      - 機制：Bloom filter 是一種概率型數據結構，可快速判斷元素「可能存在」或「絕對不存在」於集合中。預先將所有合法的資料鍵（如有效商品ID）存入 Bloom filter。
      - 操作流程：
        - 請求到達時，先通過 Bloom filter 檢查查詢的鍵是否可能存在。
        - 若返回「不存在」，直接拒絕請求，避免查詢快取與資料庫。
        - 若返回「可能存在」，則繼續查詢快取或資料庫。
      - 注意點：Bloom filter 有誤判率（False Positive），需根據記憶體容量調整哈希函數與位陣列的長度，典型誤判率可控制在1%以下。

    - 互斥鎖定Mutex Lock

      - 機制：當 Bloom filter 判斷鍵可能存在但快取未命中時，防止多個請求同時重建快取。
      - 操作流程：- 第一個請求發現快取未命中時，獲取分散式鎖（如 Redis 的 SETNX 命令）。
      - 其他併發請求進入等待狀態（如輪詢或阻塞），直到鎖釋放後直接讀取已重建的快取。
      - 獲鎖的請求查詢資料庫，若數據存在則寫入快取；若不存在，則在 Bloom filter 記錄該鍵（或設置短期空值快取）。
      - 注意點：需設置鎖的超時時間，避免因服務崩潰導致死鎖。

    - 應用場景：電商平台的限時促銷活動中，防止惡意爬蟲大量請求無效商品ID。

- 冷啟動策略：預熱腳本 + 漸進式載入

  - 系統啟動或擴容時，快取為空，此時大量請求直接訪問資料庫導致延遲飆升甚至崩潰。
  - 預熱腳本（Warm-up Script）

    - 機制：根據歷史訪問數據（如熱門商品、近期活躍用戶資料），在服務上線前主動加載至快取。
    - 操作方式：
      - 腳本分析日誌提取高頻訪問鍵列表。
      - 分批非同步將資料從資料庫查詢並寫入快取，避免一次性佔滿頻寬。

  - 漸進式載入（Progressive Loading）

    - 機制：當預熱未涵蓋的數據被請求時，逐步填充快取，而非一次性加載所有關聯數據。
    - 操作流程：
      - 首次請求未命中快取時，異步觸發數據加載，先返回部分資料（如基本資訊），後續逐步載入細節（如圖片、評論）。
      - 使用「寫入穿透」（Write-through）模式，更新資料時同步更新快取。
    - 優勢：平滑處理長尾請求，避免冷啟動期間資料庫被壓垮。
    - 應用場景：新聞平台在每日淩晨低峰期預熱頭條新聞，用戶訪問時再逐步載入相關推薦內容。

- 多層次快取：L1/L2 快取階層架構（本地+分散式）
  - 單一快取層難以平衡效能與擴展性，例如本地緩存速度快但容量有限，分散式緩存擴展性好但延遲較高。
  - 分層架構
    - L1（本地快取）：部署於應用伺服器記憶體中（如 Ehcache、Caffeine），用於存放高頻且不易變更的數據（如用戶權限）。
    - L2（分散式快取）：集中式緩存服務（如 Redis、Memcached），存放共享且容量較大的數據（如全域配置）。
  - 協調機制
    - 讀取策略：先查 L1，未命中則查 L2，並將結果回填 L1。
    - 寫入策略：採用「寫入穿透」同步更新 L2 和 L1，或透過「發布訂閱」通知其他節點失效 L1 緩存。
    - 一致性保障：為 L1 設置較短 TTL，或使用版本號強制淘汰舊數據。
  - 效能提升
    - 降低延遲：90% 請求可透過 L1 響應（如微服務中用戶 Session 管理）。
    - 分流壓力：L2 僅需處理 L1 未命中的請求，節省網路開銷。
- 失效策略矩陣：根據資料類型制定TTL/淘汰演算法
  - 不同數據特性（如時效性、存取頻率），需客製化失效策略以平衡命中率與資源成本。
    | 資料類型 | TTL 策略 | 淘汰演算法 | 其他機制 |
    |----------------|--------------------|-------------|---------------------|
    | 用戶會話 | 固定 30 分鐘 | LRU | 主動續期（滑動過期） |
    | 商品庫存 | 動態 TTL（5~60秒） | FIFO | 庫存變更時主動失效 |
    | 新聞文章 | 長 TTL（24小時） | LFU | 人工刷新按鍵失效 |
    | 廣告配置 | 永不過期 | 無 | 依版本號強制覆寫 |
