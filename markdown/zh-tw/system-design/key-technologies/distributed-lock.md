# Distributed Lock

當多個分散式系統/進程需協調存取共享資源時（如Ticketmaster演唱會票券搶購系統），需採用時效性資源鎖定機制。傳統ACID資料庫的事務鎖定（transaction locks）僅適用短期操作，它們不是為長期鎖定而設計的。這就是分散式鎖定派上用場的地方。當被問及分散式鎖定時，應涵蓋CAP權衡、腦裂處理、鎖定風暴預防等進階議題，並結合實際案例說明。

## 運作特點：

- 鎖定時效性（通常秒~分鐘級，如Ticket保留10分鐘）
- 跨節點一致性保證
- 自動失效防死鎖（crash recovery機制）

## 鎖定流程

- 鎖定申請：Client A透過原子操作取得資源鎖
- 業務處理：執行票券保留/付款等關鍵操作
- 鎖定釋放：刪除鍵值或等待TTL過期
- 失效容錯：Client B在鎖定過期後可重新競爭

## 常見題型：

- 電子商務結帳系統： 在結帳期間，使用分散式鎖定將高需求商品（例如限量版運動鞋）在用戶的購物車中保留一段短時間（例如 10 分鐘），以確保在一個用戶完成付款流程時，該商品不會被賣給其他人。
- 共享乘車配對： 分散式鎖定可用於管理司機與乘客的分配。當乘客請求乘車時，系統可以鎖定附近的司機，防止他們同時與多個乘客配對。此鎖定可以保留到司機確認或拒絕乘車，或直到經過一定時間。
- 分散式 Cron 任務： 對於在多個伺服器上運行排程任務（cron 任務）的系統，分散式鎖定確保任務一次僅由一個伺服器執行。例如，在資料分析平台中，每日任務會彙總用戶資料以生成報告。分散式鎖定可以防止多個伺服器重複執行此任務，從而節省運算資源。
- 線上拍賣競標系統： 在線上拍賣中，分散式鎖定可用於競標的最後時刻，以確保在最後幾秒內下達競標時，系統會短暫鎖定該商品以處理競標並更新當前最高競標，防止其他用戶同時對同一商品下達競標。

## 細節

- Locking Mechanisms: 實現分散式鎖定有多種方法。一種常見的實現方式使用 Redis，稱為 Redlock。Redlock 使用多個 Redis 實例，以確保安全且一致地獲取和釋放鎖定。
  | 技術方案 | 鎖定原理 | 失效處理機制 | 適用場景 |
  | ------------- | ---------------------------------- | ------------------- | ------------------ |
  | Redis RedLock | SETNX + Lua腳本 | TTL自動過期 | 高吞吐量短期鎖定 |
  | Zookeeper | 順序臨時節點(EPHEMERAL_SEQUENTIAL) | Session斷連自動刪除 | 強一致性需求場景 |
  | etcd | Lease機制 + Revision版本控制 | Lease過期自動釋放 | Kubernetes生態整合 |

- Lock Expiry: 分散式鎖定可以設定為在一定時間後過期。這對於確保如果程序崩潰或被終止，鎖定不會卡在鎖定狀態非常重要。
- Locking Granularity: 分散式鎖定可用於鎖定單一資源或一組資源。例如，您可能想要鎖定票務系統中的單張門票，或者您可能想要鎖定體育場某個區域的一組門票。
  - 細粒度鎖定：單張票券鎖定（ticket-5678）
    - 優點：最大化並發處理能力
    - 缺點：管理數百萬級鎖定需高效能儲存
  - 粗粒度鎖定：整個演唱會區域鎖定（section-b2）
    - 優點：減少鎖定操作次數
    - 缺點：可能造成熱點競爭問題
- Deadlocks: 當兩個或多個程序等待彼此釋放鎖定時，可能會發生死鎖。想想這樣一種情況：兩個程序同時嘗試獲取兩個鎖定。一個程序獲取鎖定 A，然後嘗試獲取鎖定 B，而另一個程序獲取鎖定 B，然後嘗試獲取鎖定 A。這可能導致兩個程序都在等待彼此釋放鎖定，從而導致死鎖。您應該準備好討論如何防止這種情況——一個常見的錯誤是從分散的基礎設施或程式碼中獲取鎖定，這使得識別和防止死鎖變得困難。
  - 解決方案：
    - 全局鎖定順序：強制所有進程按固定順序取得鎖定（如字母排序）
    - 鎖定超時機制：設定取得鎖定等待時限（如 500ms 未取得即放棄）
    - 分散式死鎖檢測：週期性運行檢測演算法（如圖論環路偵測）
