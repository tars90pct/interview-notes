# Queue

佇列（Queue）在系統設計中扮演緩衝區與任務分配器的雙重角色，其核心價值在於解耦生產者（Producer）與消費者（Consumer），並平滑系統負載。

:::TIPS
請謹慎將Queue引入同步工作負載。如果你的延遲要求較高（例如 < 500ms），加入Queue幾乎肯定會導致超過該延遲限制。
:::

## 核心功能：

- 流量平滑化：

  - 情境：系統每秒最多處理 200 個請求，但突發 1,000 個請求湧入。
  - 運作：800 個請求暫存於佇列，按處理能力逐步消化，避免服務崩潰。
  - 優勢：請求不會被丟棄，僅延遲處理。

- 解耦：

  - 生產者與消費者無需感知彼此存在，可獨立擴展
  - Producer在cluster拓展來處理高併發寫入
  - Consumer動態調整以適應運算密集型任務

- 容錯與恢復：
  - 消費者故障時，任務保留在佇列中，重啟後繼續處理。
  - 可實作「死信佇列（DLQ）」收集多次失敗的任務供後續排查。

## 使用案例

- 突發流量緩衝：共享乘車平台（如 Uber）
  - 挑戰：高峰時段（如跨年夜）或特殊活動（如演唱會散場）導致叫車請求暴增。
  - 解決方案：叫車請求先寫入佇列（如 Kafka）。派單服務（消費者）按處理能力從佇列拉取請求，匹配司機與乘客。
  - 效益：
    - 避免伺服器瞬間過載（5xx 錯誤）。
    - 用戶收到「請求已接收」回饋，體驗不中斷。
- 分散式工作分配：雲端照片處理服務
  - 挑戰：高解析度圖片濾鏡處理（如灰階化、人像優化）消耗大量 CPU/GPU 資源。
  - 解決方案：用戶上傳照片後，生成任務寫入佇列（如 RabbitMQ）。多台 Worker 節點（消費者）競爭拉取任務，平行處理後上傳結果至儲存服務。
  - 效益：
    - 自動平衡 Worker 負載（如空閒節點優先取得任務）。
    - 可彈性擴展 Worker 數量應對任務潮汐。

## 不適用的場景

- 低延遲同步處理（如即時支付）

  佇列引入額外延遲（寫入 + 輪詢），可能違反 SLA（如 <500ms 回應）。改用直接 API 呼叫 + 非阻塞異步通知。

- 強事務一致性需求（如庫存扣減）

  佇列無法保證 ACID。改用資料庫交易 + 兩階段提交（2PC）。

## 注意事項

- Message Ordering:

  大多數佇列採用 FIFO（先進先出）方式，表示訊息會按照接收的順序進行處理。然而，某些佇列（如 Kafka）允許更複雜的順序保證，例如根據指定的優先級或時間進行排序。

- Retry Mechanisms:

  許多Queue內建重試機制，會嘗試重新傳遞訊息多次，直到達到指定次數後才視為失敗。你可以設定重試策略，例如每次重試的延遲時間，以及最大重試次數。

- Dead Letter Queues:

  DLQ用於儲存無法處理的訊息，對於偵錯和稽核非常有用。它允許你檢查處理失敗的訊息，並分析失敗原因。

- Scaling with Partitions:

  Queue可以透過分區（Partitioning）拆分到多台伺服器，以擴展處理能力。每個分區可由不同的 worker 負責處理。類似於資料庫分區，你需要指定 分區鍵（Partition Key） 來確保相關訊息存儲在同一個分區內。

- Backpressure:

  Queue的一大問題是，它容易讓系統超載而不自知。例如，如果系統每秒最多能處理 200 個請求，但實際收到 300 個請求，那麼這些請求永遠無法全部處理完。Queue只是掩蓋了「系統處理能力不足」的問題。解決方案是背壓（Backpressure），它能在Queue過載時減緩訊息生產速度，防止Queue成為系統瓶頸。透過設定Queue最大長度，超限時觸發降級（如拒絕新任務或啟用限流）。可能需要向使用者或生產者回傳錯誤，讓他們知道系統已超載。
