# Delivery Framework

> 在系統設計面試中，最容易讓你失去錄取機會的方法，就是無法在短時間內提出一個可行的系統。這是大部分我們在這些面試中失敗的最常見原因，而且通常會以模糊的「時間管理」問題呈現。這並不代表我們要像饒舌歌手那樣提高我們的語速跟大腦的轉速，很多時候，我們只是需要專注於正確的事情。

::Tips
透過這種結構化的面試方式，您能專注於面試官最重視的核心內容。額外的好處是，即使您感到壓力過大，仍有一條清晰的路徑可以依循。許多面試者在面試中會感到緊張。若不以線性方式逐步建構解決方案，很容易迷失方向。
::

## 記憶重點

- 記住以下步驟跟細節，練習跟面試的時候都盡可能地用以下節奏進行：
  - Requirements (~5 minutes)
    - Functional Requirements
    - Non-functional Requirements
      - CAP Theorem
      - Environment Constraints
      - Scalability
      - Latency
      - Durability
      - Security
      - Fault Tolerance
      - Compliance
    - Capacity Estimation
  - Core Entities (~2 minutes)
  - API or System Interface (~5 minutes)
    - RESTful API
    - GraphQL API
    - Wire Protocol
  - [Optional] Data Flow (~5 minutes)
  - High Level Design (~10-15 minutes)
  - Deep Dives (~10 minutes)

## Delivery Framework

- Requirements (~5 minutes)

  需求分析是為了清楚的理解等等要設計的系統細節，我們建議分為下列兩部分討論：

  - Functional Requirements

    功能性需求(Functional Requirements)是你的「使用者/客戶應能...」陳述。這些是系統的核心功能，且應該是你與面試官討論的首要事項。通常這會是一個與面試官來回溝通的過程。**像與客戶、使用者或產品經理對話般提出針對性問題**(例如「系統是否需要做到 X？」、「如果發生 Y 情況會如何？」)，以釐清核心功能的優先級清單。
    舉例來說，

        若你要設計像 Twitter 的系統，功能性需求可能包含：
        - 使用者應能發布推文(post tweets)
        - 使用者應能追蹤其他使用者
        - 使用者應能查看所追蹤使用者的推文

        而一個快取(cache)系統的需求可能包含：
        - 客戶端應能插入項目(insert items)
        - 客戶端應能設定過期時間(set expirations)
        - 客戶端應能讀取項目(read items)

    ::TIPS
    **保持需求精準聚焦！** 後續面試的主要目標是設計出符合這些需求的系統——因此策略性地排定優先級至關重要。許多系統可能有數百項功能，但你的任務是辨識並優先處理前 3 大核心需求。列出一長串需求清單反而弊大於利，許多頂級企業會直接評估你「聚焦關鍵」的能力。
    ::

  - Non-functional Requirements

    非功能性需求(Non-functional Requirements)是關於系統品質的陳述，這些品質對使用者至關重要。通常可以表述為「系統應能夠...」或「系統應具備...」的句式。

    例如，若你要設計像 Twitter 的系統，非功能性需求可能包含：

    - **系統應具備高可用性(high availability)**，優先保證可用性而非一致性(prioritizing availability over consistency)
    - **系統應能擴展至支援 1 億以上日活躍用戶(100M+ DAUs)**
    - **系統應維持低延遲(low latency)**，在 200 毫秒內渲染動態訊息流

    ::TIPS
    **關鍵在於將非功能性需求結合系統情境，並盡可能量化指標**。例如單純說「系統應低延遲」既籠統又無意義——幾乎所有系統都該低延遲。而「搜尋功能應維持低延遲，<500ms」則明確指出需要優化的系統部分，並提供可衡量的目標。
    ::
    制定非功能性需求可能具有挑戰性，尤其在不熟悉領域時。以下檢查清單可協助辨識系統最重要的非功能性需求，建議聚焦在與系統最相關的 **3-5 項核心需求**：

    - CAP Theorem(CAP 定理)

      - 系統應優先考慮一致性(Consistency)還是可用性(Availability)? 注意：在分散式系統中，**分區容錯性(Partition Tolerance)** 是必要前提

    - Environment Constraints(環境約束)

      - 系統運行環境是否存在特殊限制？例如：
        - 是否部署在電池壽命有限的移動裝置？
        - 是否運行於記憶體有限或頻寬受限的裝置？(例如在 3G 網路串流影片)

    - Scalability(擴展性)

      - 所有系統皆需擴展，但此系統是否有獨特需求？例如：
        - **流量突增模式**：是否在特定時段(如每日高峰)出現爆發性流量？
        - **事件驅動擴容**：節假日等特殊事件是否會導致流量激增？
        - **讀寫比例**：系統更需擴展讀取還是寫入能力？

    - Latency(延遲)

      - 系統需要多快回應使用者請求？特別需考量需要複雜運算的操作。例：設計 Yelp 時，需確保搜尋功能的低延遲

    - Durability(持久性)

      - 數據防丟失的重要性為何？例如：
      - 社交網路可容忍部分數據遺失
      - 金流交易系統**絕對不可**丟失數據

    - Security(安全性)

      - 系統需達到何種安全等級？需考量**資料保護(Data Protection)**，**存取控制(Access Control)**和**法規合規性(如 GDPR、HIPAA)**

    - Fault Tolerance(容錯能力)

      - 系統需如何處理故障？需設計：
        - 冗餘機制(Redundancy)
        - 故障轉移(Failover)
        - 復原機制(Recovery)

    - Compliance(合規性)

      - 是否存在法律或監管要求？需考量：**產業標準(如 PCI DSS)，資料保護法規和地區性特殊規範(如中國的網路安全法)**

  - Capacity Estimation

    許多指南會建議在此階段進行**粗略估算(back-of-the-envelope calculations)**，但我們認為這通常不必要。**僅在計算結果會直接影響設計決策時才需進行數學估算**。在多數情境中，您面對的是大型分散式系統——直接假設系統規模龐大是完全合理的。許多面試者花時間計算儲存量、DAU(日活躍用戶數)和 QPS(每秒查詢量)，最終結論卻只是：「好的，數據量很大。明白了。」對面試官而言，這除了證明您會基本算術外毫無價值。

    實務建議上的建議是，向面試官說明「希望先跳過估算環節，將在設計過程中按需進行計算」。當估算結果將**實質影響架構選擇**時，我們可以適當的展示**工程判斷力**(何時/為何需要計算)，重點在建立**數量級敏感度**(例如 MB vs GB vs TB 的差異)：

    - 範例：設計 Facebook 貼文趨勢話題的 TopK 系統時
      - 需預估可能出現的熱門話題數量
      - 這將決定能否使用單個最小堆(min-heap)資料結構
      - 或需要將資料**分片(shard)到多個實例**

    ::TIPS
    無論在面試中如何運用估算技巧，培養快速預估關鍵數量的能力將幫助您：

    1. 在架構決策時更有效率地權衡利弊
    2. **建立數量級直覺**

    多數工程師(包含資深者)在實務中都會使用白板輔助計算與採用近似值估算(如將 1,234,567 簡化為 1.2M)。請專注於[數量級正確性](https://www.hellointerview.com/blog/mastering-estimation)而非精確數字
    ::

- Core Entities (~2 minutes)

  接下來，你應該花些時間辨識並列出系統的核心實體。這有助於定義術語、理解設計中的核心數據，並為後續建構奠定基礎。這些核心實體將是API交換的對象，也是系統在資料模型中持久儲存的內容。在實際面試中，只需簡單列出一個項目符號清單，並向面試官說明這是你的初步草案即可。

  為何不在此時就列出完整的資料模型？因為你無法預見未知的事物。在設計過程中，你會不斷發現未曾預料的新實體和關係。從一個精簡的清單開始，能讓你快速迭代並逐步擴充。當進入High Level Design階段，並更清楚每個請求需要更新的具體狀態後，便可開始為每個實體建構相關欄位/屬性的清單。

  以Twitter為例，我們的核心實體相當簡單：

  - 使用者(User)
  - 推文(Tweet)
  - 關注關係(Follow)

  以下幾個自問問題有助辨識核心實體：

  - 系統中的主要參與者是誰？他們的身份會重疊嗎？
  - 滿足功能需求需要哪些名詞或資源？

  ::TIPS
  請特別注意為實體選擇恰當名稱。儘管多數問題的規模小到可以用`foo`和`bar`這類代稱替代，但有些面試官會藉此觀察你是否能應對「電腦科學中最難問題之一」--命名。
  ::

- **API or System Interface (~5 minutes)**

  在進入高階設計前，你需要先定義系統與使用者之間的協定。通常這會直接對應到你已識別的功能需求(但並非絕對！)，尤其在完整產品型態的面試情境中。這個協定將引導你的高階設計，並確保能滿足已確定的需求。

  - RESTful API: 網際網路的標準通訊規範，使用 HTTP 方法(GET/POST/PUT/DELETE)對資源執行 CRUD 操作
  - GraphQL API: GraphQL 是一種 API 查詢語言，允許客戶端精確地請求所需的資料。客戶端可以指定所需的資料結構，伺服器只返回客戶端請求的資料。解決了 RESTful API 中常見的過度獲取(over-fetching)和獲取不足(under-fetching)的問題。
  - Wire Protocol: 若使用 WebSockets 或原始 TCP sockets 通訊時，需定義數據傳輸格式(通常以訊息格式呈現)
  - Protocol Buffers(protobuf): Protocol Buffers 是一種語言中立、平台中立、可擴展的序列化資料的機制。它用於定義結構化的資料，並將其序列化為二進制格式，以便在網路中傳輸或儲存。它通常與 gRPC 一起使用，gRPC 則是在HTTP/2 的基礎之上的RPC 框架，用於高效的微服務通訊。

  ::TIPS
  不必過度糾結選擇，建議優先採用 REST API。僅在確實需要避免數據過度獲取/不足獲取時才使用 GraphQL。若選擇 WebSockets，則需具體描述通訊協定格式。以下重點提示

  - 協定定義需包含端點(Endpoint)、請求/回應格式
  - 錯誤處理機制需明確規範
  - 版本控制建議採用 URL 路徑標示法（如 `/api/v1/resource`）

  ::
  在我們Twitter的例子中，我們採用RESTful API，並會有以下endpoints。請注意我們如何能將core entity用作透過 API 交換的物件。

  ```
  POST /v1/tweet
  body: {
    "text": string
  }

  GET /v1/tweet/:tweetId -> Tweet

  POST /v1/follow/:userId

  GET /v1/feed -> Tweet[]

  ```

  ::TIPS
  注意到 `POST /v1/tweet` 端點中沒有包含 `userId` 了嗎？這是因為我們會從請求標頭中的**authentication token**獲取發起請求的使用者 ID。將使用者 ID 這類敏感資訊放在請求主體中，是常見的安全風險，也是許多面試者容易犯的錯誤——請避免成為其中之一！
  ::

- [Optional] Data Flow (~5 minutes)

  對於某些後端系統（特別是**資料處理系統**），描述系統將輸入轉換為預期輸出的**高階操作序列**會很有幫助。若系統不涉及複雜操作流程，可直接跳過此步驟！

  通常我們會透過簡易清單定義資料流，這個流程將作為下一階段high level design的基礎框架。

  以**網路爬蟲**為例，典型資料流可能包含：

  - 擷取種子網址（Fetch seed URLs）
  - 解析HTML結構（Parse HTML）
  - 萃取新鏈結（Extract URLs）
  - 持久化儲存資料（Store data）
  - 循環執行上述流程（Repeat）

- **High Level Design (~10-15 minutes)**
  現在你已清楚理解系統的需求、實體和 API，接下來可以開始設計高階架構。這包含繪製方框和箭頭來表示系統的不同組件及其互動方式。組件是基本構成要素，例如伺服器、資料庫、快取等。這可以在白板上手繪完成，或使用 Excalidraw 等虛擬白板軟體進行。下方「關鍵技術」章節將提供你需要了解的常見組件參考。

  ::TIPS
  請事先向招募人員確認面試使用的繪圖軟體並提前練習，避免在面試中因操作不熟練而手忙腳亂。
  ::

  不要過度糾結！主要目標是設計出符合已規劃 API 的架構，進而滿足既定的需求。在多數情況下，你可以依序檢視 API endpoints，逐步建構設計來滿足每個端點需求。

  ::TIPS
  保持專注！常見錯誤是過早添加複雜層次，導致無法完成完整解決方案。先聚焦能滿足核心功能需求的簡潔設計，後續再於深入探討章節添加複雜度來滿足非功能性需求。在高階設計階段發現可添加複雜度的區域（例如Cache或MQ）是正常現象，建議用口頭說明和文字註記標示這些區域後繼續推進。
  ::

  繪製設計時，應同步向面試官解說思考流程。明確說明從 API 請求到響應的過程中，數據如何在系統流動，以及各項請求會改變哪些狀態（存在DB、Cache或Message Queue中）。當請求到達資料庫或持久層時，正是開始記錄各實體相關欄位/屬性的好時機。可視化地將這些資訊標註在資料庫旁，有助於保持與相關組件的關聯性，並方便後續迭代調整。此階段不需過度糾結類型標註，面試官能自行推斷，且過度標註會拖慢進度。

  ::TIPS
  不需耗時記錄資料結構中的每個欄位/屬性。舉例來說，面試官都明白使用者表會包含姓名、電子郵件和密碼雜湊值，因此無需特別標註。應重點關注與設計特別相關的欄位/屬性。
  ::

- **Deep Dives (~10 minutes)**
  **敏銳的觀察者**可能已發現，我們先前設計的 Twitter 簡化架構在取得用戶動態牆時存在嚴重效能問題。這正是**深入探討階段**需要迭代優化的重點！完成高階設計後，您將利用面試剩餘的 10-15 分鐘進行四大強化步驟：

  1. **驗證非功能性需求**：確保系統符合擴展性、延遲性等指標
  2. **處理邊界條件**：解決極端情境與異常狀況
  3. **瓶頸定位與排除**：識別潛在效能熱點並提出解決方案
  4. **動態調整設計**：根據面試官的提問即時優化架構

  所以舉例來說，我們對 Twitter 的其中一個非功能性需求是，我們的系統需要擴展到超過一億的每日活躍用戶（DAU）。接著，我們可以引導討論，圍繞著水平擴展、cache的引入，以及資料庫sharding——並在過程中更新我們的設計。另一個需求是，動態消息需要低延遲地被提取。在 Twitter 的案例中，這實際上是最有趣的問題。我們會引導討論關於fanout-on-read與fanout-on-write，以及cache的使用。以「支援 1 億日活用戶」的非功能性需求為例，可展開以下技術討論：

  - 混合式架構：對活躍用戶採用寫擴散，長尾用戶使用讀擴散
  - 多級快取設計：
    - L1: 本地快存 (Guava Cache)
    - L2: 分散式快取 (Redis Cluster)
    - L3: 持久化儲存 (Cassandra)
  - 資料庫分片技術實施（基於用戶ID的Sharding邏輯）
  - 異步處理機制：透過 Kafka 將推文發佈與粉絲列表處理解耦
  - 監控告警系統：建立 Prometheus + Grafana 監控儀表板

  ::TIPS
  應徵者常犯的一個錯誤是，他們試圖在這裡滔滔不絕地蓋過面試官。當然，有很多可以談論的，而且對於資深應徵者來說，積極主動很重要，但這是一個平衡。確保你給面試官留下提問和探究你設計的空間。他們很可能想要從你身上獲取一些訊號，如果你只顧著說話，就會錯過這些訊號。此外，你也會在溝通和協作方面的評估中受到影響。
  ::

# 內容抄襲/引用自：

[hellointerview.com](https://www.hellointerview.com/learn/system-design/in-a-hurry/delivery)
